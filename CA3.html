<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Dynamics Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Academic Teal & Amber -->
    <!-- Application Structure Plan: This advanced lab retains a familiar layout but with upgraded internals and UI. The core change is the shift from a synchronous cellular automaton to an asynchronous, evolutionary model. The control panel now includes a "Noise (K)" slider to manage the probabilistic strategy adoption (Fermi function). The visualization is a strategy-age heatmap, coloring cells by both strategy and stability. The analysis section is enhanced with a new "Global Productivity" chart alongside the population chart, providing a richer dataset for interpreting the emergent patterns, which are now stable territories and fronts rather than chaotic oscillations. All interactive components are now annotated with tooltips to ensure the lab is fully self-explanatory. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Evolutionary dynamics -> Goal: Demonstrate stable emergent structures -> Viz/Presentation: HTML Canvas rendering a strategy-age heatmap. -> Interaction: Live simulation. Color lightness/saturation is tied to how long a cell has held its strategy. -> Justification: This visually distinguishes stable "core" territories from volatile "frontier" zones, making patterns of emergence dramatically more evident and intuitive.
        - Report Info: User understanding of lab components -> Goal: Make the tool self-explanatory -> Viz/Presentation: HTML/CSS tooltips on info icons next to all key UI elements (Payoffs, Charts, Sliders). -> Interaction: Hovering reveals detailed text explaining the purpose and underlying logic of each component. -> Justification: This removes ambiguity and provides a built-in guide, allowing users to fully understand the experiment without prior knowledge.
        - Report Info: Overall system health -> Goal: Quantify the success of a given emergent pattern -> Viz/Presentation: A second line chart showing the sum of all cell scores on the grid. -> Interaction: Updates in real-time. -> Justification: Moves analysis beyond simple population counts to measure the total "economic output" or "well-being" of the simulated society, providing a deeper metric for success. -> Library/Method: Chart.js.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8f7f2; color: #3a3a3a; }
        .btn-primary { background-color: #008080; color: white; transition: background-color 0.3s; }
        .btn-primary:hover { background-color: #006666; }
        .btn-secondary { background-color: #e0e0e0; color: #3a3a3a; transition: background-color 0.3s; }
        .btn-secondary:hover { background-color: #cccccc; }
        .chart-container { position: relative; width: 100%; max-width: 900px; margin-left: auto; margin-right: auto; height: 35vh; max-height: 350px; }
        .tooltip { position: relative; display: inline-block; cursor: help; }
        .tooltip .tooltiptext { visibility: hidden; width: 250px; background-color: #555; color: #fff; text-align: left; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 10; bottom: 135%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; font-size: 0.8rem; font-weight: normal; line-height: 1.4; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
    </style>
</head>
<body class="antialiased">
    <div id="app" class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold mb-2">Evolutionary Dynamics Lab</h1>
            <p class="text-lg md:text-xl text-gray-600">Visualizing the Emergence of Stable Strategies</p>
        </header>

        <main>
            <section id="laboratory" class="mb-12">
                <div class="grid lg:grid-cols-3 gap-8">
                    
                    <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
                        <div class="mb-4">
                            <label for="game-select" class="block text-sm font-medium text-gray-700 mb-1">Game Model <span class="tooltip">ⓘ<span class="tooltiptext">A "Game" is a specific set of rules and payoffs that defines a strategic interaction, like the Prisoner's Dilemma.</span></span></label>
                            <select id="game-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                                <option value="prisoner">Prisoner's Dilemma</option>
                                <option value="hawk-dove">Hawk-Dove</option>
                                <option value="stag-hunt">Stag Hunt</option>
                            </select>
                        </div>

                        <div class="mb-4">
                            <label for="scenario-select" class="block text-sm font-medium text-gray-700 mb-1">Scenario <span class="tooltip">ⓘ<span class="tooltiptext">A "Scenario" is a pre-configured set of payoffs for the selected game. Each is designed to demonstrate a specific, important emergent pattern.</span></span></label>
                            <select id="scenario-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></select>
                        </div>
                        
                        <div class="mb-4 p-4 bg-gray-50 rounded-lg">
                            <label for="noise-slider" class="block text-sm font-medium text-gray-700">Noise (K): <span id="noise-value">0.1</span> <span class="tooltip">ⓘ<span class="tooltiptext">Controls randomness in strategy adoption. A low value (e.g., 0.1) means cells almost always copy a better-performing neighbor. A high value (e.g., 5.0) means they behave more randomly, introducing "mutations" by sometimes copying a worse strategy.</span></span></label>
                            <input id="noise-slider" type="range" min="0.01" max="5" value="0.1" step="0.01" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <div id="payoff-matrix" class="mb-4">
                            <label class="block text-sm font-bold text-gray-800 mb-2 text-center">Payoffs <span class="tooltip">ⓘ<span class="tooltiptext">This matrix defines the score a player gets. The grid shows: Top-Left (You Cooperate, They Cooperate), Top-Right (You Cooperate, They Defect), Bottom-Left (You Defect, They Cooperate), Bottom-Right (You Defect, They Defect).</span></span></label>
                            <div class="grid grid-cols-2 gap-4 text-center">
                                 <div><input type="number" id="payoff-cc" class="w-full p-1 text-center border rounded"></div>
                                 <div><input type="number" id="payoff-cd" class="w-full p-1 text-center border rounded"></div>
                                 <div><input type="number" id="payoff-dc" class="w-full p-1 text-center border rounded"></div>
                                 <div><input type="number" id="payoff-dd" class="w-full p-1 text-center border rounded"></div>
                            </div>
                        </div>

                        <div class="flex space-x-2 mb-4">
                            <button id="play-pause-btn" class="flex-1 py-2 px-4 btn-primary rounded-md font-semibold">Play</button>
                            <button id="reset-btn" class="flex-1 py-2 px-4 btn-secondary rounded-md">Reset</button>
                        </div>
                        <div class="text-center text-sm text-gray-500">Updates/sec: <span id="ups-display">0</span></div>
                    </div>

                    <div class="lg:col-span-2 bg-gray-900 rounded-lg shadow-lg flex items-center justify-center p-2 aspect-square">
                        <canvas id="simulation-canvas"></canvas>
                    </div>
                </div>
            </section>
            
            <section id="observations" class="bg-white p-8 rounded-lg shadow-sm">
                <div id="explanation-text" class="text-gray-700 leading-relaxed p-4 border-l-4 border-teal-500 bg-teal-50 rounded-r-lg mb-8"></div>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="chart-container">
                        <h3 class="text-xl font-bold mb-2 text-center">Population Dynamics <span class="tooltip">ⓘ<span class="tooltiptext"><b>Logic:</b> This chart shows a simple count of all cells for each strategy at every generation. It answers the question: "Which strategy is more numerous or successful at spreading?"</span></span></h3>
                        <canvas id="population-chart"></canvas>
                    </div>
                    <div class="chart-container">
                         <h3 class="text-xl font-bold mb-2 text-center">Global Productivity <span class="tooltip">ⓘ<span class="tooltiptext"><b>Logic:</b> This chart shows the sum of all scores from all cells on the grid. A cell's score is calculated from its 8 interactions with its neighbors. It measures the total "well-being" or "economic output" of the entire system. A higher score means a more productive society.</span></span></h3>
                        <canvas id="productivity-chart"></canvas>
                    </div>
                </div>
            </section> <!-- End of Observations -->

            <section id="reference" class="bg-white p-8 rounded-lg shadow-sm mt-12">
                <h2 class="text-3xl font-bold mb-8 text-center border-b pb-4">Reference: Understanding the Game Models</h2>
                
                <div class="space-y-10">
                    
                    <div>
                        <h3 class="text-2xl font-bold mb-3 text-teal-700">Prisoner's Dilemma</h3>
                        <p class="mb-4 text-gray-700">This game models the conflict between individual self-interest and the collective good. The classic story involves two prisoners who are interrogated separately. If both stay silent (Cooperate), they both get a short sentence. If one betrays the other (Defects), the defector goes free while the other gets a long sentence. If both betray each other, they both get a medium sentence. The "dilemma" is that it's always in your personal best interest to defect, but if both players do that, you end up with a worse outcome than if you had both cooperated.  It's a model for trust, betrayal, and the tragedy of the commons.</p>
                        
                        <div class="pl-4 border-l-4 border-gray-200 space-y-3">
                            <div>
                                <h4 class="font-semibold">Scenario: Stable Territories</h4>
                                <p class="text-sm text-gray-600">This shows that even in a world with incentives to betray, cooperation can survive by forming dense, defensive clusters. These "territories" are like high-trust societies that are resilient to outside exploitation because the cooperators mutually support each other.</p>
                            </div>
                            <div>
                                <h4 class="font-semibold">Scenario: Resilient Cooperation</h4>
                                <p class="text-sm text-gray-600">This demonstrates how social structures or laws can foster cooperation. By increasing the reward for cooperating and making mutual defection very costly, the system is engineered to make cooperation the most rational long-term strategy. This leads to a highly productive and stable society.</p>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-bold mb-3 text-teal-700">Hawk-Dove</h3>
                        <p class="mb-4 text-gray-700">This game models conflict and aggression over a shared resource. A "Dove" (Cooperate) will share the resource peacefully. A "Hawk" (Defect) will always fight for the resource. If two Doves meet, they share. If a Hawk meets a Dove, the Hawk wins. But if two Hawks meet, they have a costly fight, risking injury. Neither strategy is always superior; their success depends on what everyone else is doing. It's a model for understanding ritualized conflict, animal behavior, and when to be aggressive versus when to back down.</p>
                        
                        <div class="pl-4 border-l-4 border-gray-200 space-y-3">
                             <div>
                                <h4 class="font-semibold">Scenario: Invasive Spirals</h4>
                                <p class="text-sm text-gray-600">This beautiful pattern is the visual signature of a dynamic equilibrium. A wave of Doves provides an easy food source for Hawks, so a wave of Hawks follows. But once the Hawks become too numerous, they mostly fight each other, causing their population to crash, which allows the Dove wave to recover. It's a classic predator-prey cycle.</p>
                            </div>
                            <div>
                                <h4 class="font-semibold">Scenario: Dove Sanctuaries</h4>
                                <p class="text-sm text-gray-600">This shows what happens when conflict becomes too costly to be worth the risk (e.g., mutually assured destruction). The Hawk strategy becomes self-defeating, allowing large, peaceful, and highly productive societies of Doves to emerge and dominate the grid.</p>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-2xl font-bold mb-3 text-teal-700">Stag Hunt</h3>
                        <p class="mb-4 text-gray-700">This game models the importance of social coordination and trust. Two hunters can choose to cooperate to hunt a large stag, which is a huge reward but requires both of them to succeed. Alternatively, either hunter can choose to defect at any time to hunt a small hare, which is a smaller but guaranteed solo reward. It's not about betrayal, but about faith in your partner's competence and commitment. It models the tension between risky but highly rewarding teamwork and safe, independent action.</p>

                        <div class="pl-4 border-l-4 border-gray-200 space-y-3">
                            <div>
                                <h4 class="font-semibold">Scenario: Dominant Coordination</h4>
                                <p class="text-sm text-gray-600">This scenario represents a high-trust society where the benefits of teamwork are clear and everyone is confident in their partners. Cooperation (hunting the stag) quickly becomes the dominant strategy, leading to a swift and decisive victory and a highly productive outcome.</p>
                            </div>
                            <div>
                                <h4 class="font-semibold">Scenario: The Price of Fear</h4>
                                <p class="text-sm text-gray-600">This shows a low-trust society where the fear of your partner failing is high, and the safe solo option is appealing. Individuals are unwilling to take the risk of cooperation, so the less productive "hare hunter" strategy dominates. The lower Global Productivity score reveals the economic cost of this lack of social trust.</p>
                            </div>
                        </div>
                    </div>

                </div>
            </section>

        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');

        const gameSelect = document.getElementById('game-select');
        const scenarioSelect = document.getElementById('scenario-select');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const noiseSlider = document.getElementById('noise-slider');
        const noiseValue = document.getElementById('noise-value');
        const explanationText = document.getElementById('explanation-text');
        const upsDisplay = document.getElementById('ups-display');

        const payoffInputs = {
            cc: document.getElementById('payoff-cc'), cd: document.getElementById('payoff-cd'),
            dc: document.getElementById('payoff-dc'), dd: document.getElementById('payoff-dd')
        };
        
        const experiments = {
            prisoner: {
                scenarios: {
                    classic: { name: "Stable Territories", payoffs: { cc: 3, cd: 0, dc: 5, dd: 1 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: Stable Territories</h4><p>With evolutionary dynamics, the classic dilemma no longer produces chaos. <b>What to look for:</b> Watch for coherent territories of cooperators (teal) to form. Notice the bright "foam" at the borders where conflict occurs. Defectors (amber) can still invade, but they do so as a solid front, not as chaotic noise.</p>`},
                    cooperative: { name: "Cooperative World", payoffs: { cc: 5, cd: 0, dc: 6, dd: -5 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: Resilient Cooperation</h4><p>We've rewarded cooperation and punished defection. <b>What to look for:</b> Cooperation should now be the dominant strategy. Watch how quickly the amber territories collapse. The Global Productivity score should be significantly higher than in the classic scenario, demonstrating a healthier overall society.</p>` }
                }
            },
            'hawk-dove': {
                 scenarios: {
                    classic: { name: "Invasive Spirals", payoffs: { cc: 3, cd: 2, dc: 4, dd: 1 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: Invasive Spirals</h4><p>The Hawk-Dove dynamic is famous for creating beautiful, chasing spiral patterns under these rules. <b>What to look for:</b> Instead of static, you'll see waves of Hawks (amber) chasing waves of Doves (teal). This is a visual representation of a stable predator-prey-like cycle.</p>`},
                    costly_war: { name: "Dove Sanctuaries", payoffs: { cc: 3, cd: 2, dc: 4, dd: -10 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: Dove Sanctuaries</h4><p>By making Hawk-Hawk conflict catastrophic, the Hawk strategy becomes much less viable. <b>What to look for:</b> The spirals should break down, replaced by large, stable 'sanctuaries' of Doves. The Productivity score will likely be high and stable, as peaceful sharing replaces costly conflict.</p>`}
                }
            },
            'stag-hunt': {
                scenarios: {
                    classic: { name: "Dominant Coordination", payoffs: { cc: 5, cd: 0, dc: 3, dd: 1 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: Dominant Coordination</h4><p>In this trust-based game, coordination is extremely powerful. <b>What to look for:</b> The grid should very quickly resolve into a nearly solid block of cooperators (Stag Hunters). The victory is swift and decisive. This demonstrates how a high-trust, high-reward strategy can completely dominate a system.</p>`},
                    low_trust: { name: "The Price of Fear", payoffs: { cc: 5, cd: 0, dc: 4, dd: 2 }, explanation: `<h4 class='font-bold text-lg mb-2'>Experiment: The Price of Fear</h4><p>Here, the 'safe' solo option is almost as good as the cooperative one. <b>What to look for:</b> Pockets of cooperators will struggle to form. The Hare Hunter strategy will dominate. Compare the final Global Productivity score here to the 'Dominant Coordination' scenario to see the economic 'price' of a low-trust society.</p>`}
                }
            }
        };

        const COOPERATE = 0, DEFECT = 1;
        let gridSize = 100, grid, ageGrid, maxAge = 200, payoffs = {}, noise = 0.1;
        let isPlaying = false, animationFrameId, lastUpdateTime = 0, updates = 0;
        let generation = 0, updatesSinceGeneration = 0;
        
        const populationChart = new Chart(document.getElementById('population-chart').getContext('2d'), { type: 'line', data: { labels: [], datasets: [{label:'Cooperators', data:[], borderColor:'#008080', tension:0.1}, {label:'Defectors', data:[], borderColor:'#ffa500', tension:0.1}] }, options: { responsive: true, maintainAspectRatio: false, animation: {duration: 0} } });
        const productivityChart = new Chart(document.getElementById('productivity-chart').getContext('2d'), { type: 'line', data: { labels: [], datasets: [{label:'Total Score', data:[], borderColor:'#4c51bf', tension:0.1}] }, options: { responsive: true, maintainAspectRatio: false, animation: {duration: 0} } });

        function setupCanvas() {
            const size = Math.min(canvas.parentElement.clientWidth, canvas.parentElement.clientHeight);
            canvas.width = size; canvas.height = size;
        }

        function populateScenarios() {
            const gameData = experiments[gameSelect.value];
            scenarioSelect.innerHTML = Object.keys(gameData.scenarios).map(key => `<option value="${key}">${gameData.scenarios[key].name}</option>`).join('');
            updateScenario();
        }

        function updateScenario() {
            const scenario = experiments[gameSelect.value].scenarios[scenarioSelect.value];
            payoffs = { ...scenario.payoffs };
            Object.keys(payoffs).forEach(key => payoffInputs[key].value = payoffs[key]);
            explanationText.innerHTML = scenario.explanation;
            handleReset();
        }

        function initializeGrids() {
            grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null).map(() => Math.random() < 0.5 ? COOPERATE : DEFECT));
            ageGrid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
            generation = 0; updatesSinceGeneration = 0;
        }

        function drawGrid() {
            const cellSize = canvas.width / gridSize;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const age = Math.min(ageGrid[y][x], maxAge);
                    const normalizedAge = age / maxAge;
                    const strategy = grid[y][x];
                    
                    const hue = strategy === COOPERATE ? 180 : 40;
                    const saturation = 90;
                    const lightness = 80 - (50 * normalizedAge);
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function getScore(y, x) {
            let score = 0;
            const myStrategy = grid[y][x];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const ny = (y + dy + gridSize) % gridSize, nx = (x + dx + gridSize) % gridSize;
                    const neighborStrategy = grid[ny][nx];
                    if (myStrategy === COOPERATE && neighborStrategy === COOPERATE) score += payoffs.cc;
                    else if (myStrategy === COOPERATE && neighborStrategy === DEFECT) score += payoffs.cd;
                    else if (myStrategy === DEFECT && neighborStrategy === COOPERATE) score += payoffs.dc;
                    else if (myStrategy === DEFECT && neighborStrategy === DEFECT) score += payoffs.dd;
                }
            }
            return score;
        }

        function updateCell() {
            const x = Math.floor(Math.random() * gridSize);
            const y = Math.floor(Math.random() * gridSize);

            const dx = Math.floor(Math.random() * 3) - 1;
            const dy = Math.floor(Math.random() * 3) - 1;
            if (dx === 0 && dy === 0) return;

            const nx = (x + dx + gridSize) % gridSize;
            const ny = (y + dy + gridSize) % gridSize;

            const myScore = getScore(y, x);
            const neighborScore = getScore(ny, ny);
            
            const probability = 1 / (1 + Math.exp((myScore - neighborScore) / noise));

            if (Math.random() < probability) {
                if (grid[y][x] !== grid[ny][nx]) {
                    grid[y][x] = grid[ny][nx];
                    ageGrid[y][x] = 0;
                }
            }
        }
        
        function updateCharts() {
            let counts = { [COOPERATE]: 0, [DEFECT]: 0 };
            let totalScore = 0;
            for(let y=0; y<gridSize; y++) {
                for(let x=0; x<gridSize; x++) {
                    counts[grid[y][x]]++;
                    totalScore += getScore(y, x);
                }
            }

            const chartUpdate = (chart, ...data) => {
                if (chart.data.labels.length > 100) {
                    chart.data.labels.shift();
                    chart.data.datasets.forEach(d => d.data.shift());
                }
                chart.data.labels.push(generation);
                data.forEach((d, i) => chart.data.datasets[i].data.push(d));
                chart.update();
            };
            
            chartUpdate(populationChart, counts[COOPERATE], counts[DEFECT]);
            chartUpdate(productivityChart, totalScore);
        }

        function gameLoop(timestamp) {
            if (!isPlaying) return;

            const updatesPerFrame = 1000;
            for(let i=0; i < updatesPerFrame; i++) {
                updateCell();
                ageGrid[Math.floor(Math.random() * gridSize)][Math.floor(Math.random() * gridSize)]++;
            }
            updates += updatesPerFrame;
            updatesSinceGeneration += updatesPerFrame;
            
            if(updatesSinceGeneration >= gridSize * gridSize) {
                generation++;
                updatesSinceGeneration = 0;
                updateCharts();
            }

            drawGrid();

            if (timestamp - lastUpdateTime > 1000) {
                upsDisplay.textContent = updates.toLocaleString();
                updates = 0;
                lastUpdateTime = timestamp;
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function handlePlayPause() { isPlaying = !isPlaying; playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play'; if (isPlaying) { lastUpdateTime = performance.now(); requestAnimationFrame(gameLoop); } else { cancelAnimationFrame(animationFrameId); } }
        function handleReset() { if (isPlaying) handlePlayPause(); initializeGrids(); drawGrid(); [populationChart, productivityChart].forEach(c => { c.data.labels=[]; c.data.datasets.forEach(d => d.data=[]); c.update(); }); }
        
        gameSelect.addEventListener('change', populateScenarios);
        scenarioSelect.addEventListener('change', updateScenario);
        playPauseBtn.addEventListener('click', handlePlayPause);
        resetBtn.addEventListener('click', handleReset);
        noiseSlider.addEventListener('input', e => { noise = parseFloat(e.target.value); noiseValue.textContent = noise.toFixed(2); });
        Object.values(payoffInputs).forEach(input => input.addEventListener('change', () => {
             payoffs = Object.keys(payoffInputs).reduce((acc, key) => ({ ...acc, [key]: parseFloat(payoffInputs[key].value) }), {});
             // scenarioSelect.value = 'custom'; // This would require a "Custom" option to be added
        }));
        
        window.addEventListener('resize', () => { setupCanvas(); drawGrid(); });

        setupCanvas();
        populateScenarios();
    });
    </script>
</body>
</html>


